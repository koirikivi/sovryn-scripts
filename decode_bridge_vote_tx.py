import argparse
import warnings
from typing import Optional

import pandas as pd
from eth_abi import decode_abi
from eth_utils import is_hexstr, to_bytes, to_hex

from utils import load_abi

FEDERATION_ABI = load_abi('token_bridge/Federation')

VOTE_TRANSACTION_ABI = [x for x in FEDERATION_ABI if x.get('name') == 'voteTransaction'][0]
VOTE_TRANSACTION_PARAMETER_TYPES = [x['type'] for x in VOTE_TRANSACTION_ABI['inputs']]
VOTE_TRANSACTION_PARAMETER_NAMES = [x['name'] for x in VOTE_TRANSACTION_ABI['inputs']]


def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--tx-data-hex', help='transaction data as 0x prefixed hex')
    group.add_argument('--manually-check-file', help='path to manuallyCheck.txt')
    parser.add_argument('--transfer-csv-file',
                        help='transfer file as generated by bridge_transfer_status.py to show data of transaction')
    args = parser.parse_args()

    transfer_dataframe = None
    if args.transfer_csv_file:
        transfer_dataframe = pd.read_csv(args.transfer_csv_file)

    if args.tx_data_hex:
        decode_votetransaction_hex_data(args.tx_data_hex, transfer_dataframe=transfer_dataframe)
    elif args.manually_check_file:
        with open(args.manually_check_file) as f:
            decode_lines_in_manually_check_file(f, transfer_dataframe=transfer_dataframe)


def decode_votetransaction_hex_data(tx_data_hex: str, *, transfer_dataframe: Optional[pd.DataFrame] = None):
    tx_data_bytes = to_bytes(hexstr=tx_data_hex)
    tx_data_function_selector = tx_data_bytes[:4]
    tx_data_function_selector_hex = to_hex(tx_data_function_selector)
    if tx_data_function_selector_hex != '0xd03e1ee9':
        warnings.warn(
            f"Function selector {tx_data_function_selector_hex!r} doesn't match expected voteTransaction selector"
        )
    tx_data_bytes_without_function_selector = tx_data_bytes[4:]
    parameter_values = decode_abi(
        types=VOTE_TRANSACTION_PARAMETER_TYPES,
        data=tx_data_bytes_without_function_selector,
    )
    parameter_value_map = {}

    print('voteTransaction(')
    for name, value in zip(VOTE_TRANSACTION_PARAMETER_NAMES, parameter_values):
        if isinstance(value, bytes):
            value = to_hex(value)

        parameter_value_map[name] = value

        if isinstance(value, str) and not is_hexstr(value):
            value_repr = f'"{value}"'
        else:
            value_repr = value
        print(f'    {name}={value_repr},')
    print(')')

    if transfer_dataframe is not None:
        matching = transfer_dataframe[
            (transfer_dataframe["event_transaction_hash"] == parameter_value_map['transactionHash']) &
            (transfer_dataframe["event_log_index"] == parameter_value_map['logIndex'])
        ]
        matching_rows = matching.to_dict(orient='records')
        print(f'Found {len(matching_rows)} matching entries from transfers CSV:')
        for i, row in enumerate(matching_rows, start=1):
            print(f'#{i}')
            for key, value in row.items():
                print(key.ljust(24), value)


def decode_lines_in_manually_check_file(f, *, transfer_dataframe: Optional[pd.DataFrame] = None):
    for line in f:
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        parts = [p.strip() for p in line.split(' ')]
        parts = [p for p in parts if p]
        data_parts = [p for p in parts if p.startswith('data:')]
        if len(data_parts) != 1:
            print("Invalid line:")
            print(line)
            continue
        data_part = data_parts[0]
        _, _, tx_data_hex = data_part.partition(':')

        parts.remove(data_part)
        print(' '.join(parts), '=>')
        decode_votetransaction_hex_data(tx_data_hex, transfer_dataframe=transfer_dataframe)
        print('')


if __name__ == '__main__':
    main()
